// üóÑÔ∏è rawDataService.js - D·ªãch v·ª• x·ª≠ l√Ω Kho D·ªØ li·ªáu Th√¥
import api from './api';

class RawDataService {
  constructor() {
    this.baseURL = '/rawdata';
  }

  // üìã L·∫•y danh s√°ch t·∫•t c·∫£ d·ªØ li·ªáu th√¥ ƒë√£ import
  async getAllImports() {
    try {
      const response = await api.get(this.baseURL);
      
      // üîß Parse .NET $values format
      let data = response.data;
      if (data && data.$values) {
        data = data.$values;
      }
      
      return {
        success: true,
        data: data || []
      };
    } catch (error) {
      console.error('‚ùå L·ªói l·∫•y danh s√°ch import:', error);
      
      // X·ª≠ l√Ω c√°c lo·∫°i l·ªói c·ª• th·ªÉ
      let errorMessage = 'L·ªói k·∫øt n·ªëi server';
      if (error.code === 'ERR_NETWORK' || error.code === 'ERR_CONNECTION_REFUSED') {
        errorMessage = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server backend. Vui l√≤ng ki·ªÉm tra:\n‚Ä¢ Server backend c√≥ ƒëang ch·∫°y?\n‚Ä¢ C·ªïng k·∫øt n·ªëi c√≥ ƒë√∫ng kh√¥ng?\n‚Ä¢ Firewall c√≥ ch·∫∑n k·∫øt n·ªëi kh√¥ng?';
      } else if (error.response?.status === 404) {
        errorMessage = 'API endpoint kh√¥ng t·ªìn t·∫°i';
      } else if (error.response?.status >= 500) {
        errorMessage = 'L·ªói server n·ªôi b·ªô';
      } else if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      }
      
      return {
        success: false,
        error: errorMessage,
        errorCode: error.code,
        errorStatus: error.response?.status,
        // Fallback data ƒë·ªÉ demo v·∫´n ho·∫°t ƒë·ªông
        fallbackData: this.getMockData()
      };
    }
  }

  // üîÑ Mock data cho demo khi server kh√¥ng c√≥
  getMockData() {
    return [
      {
        id: 'demo-1',
        dataType: 'excel',
        fileName: 'demo-data-lai-chau.xlsx',
        uploadDate: '2025-06-21T10:30:00Z',
        status: 'Completed',
        recordCount: 1250,
        fileSize: 2048576
      },
      {
        id: 'demo-2', 
        dataType: 'csv',
        fileName: 'agribank-branches.csv',
        uploadDate: '2025-06-20T15:45:00Z',
        status: 'Completed',
        recordCount: 23,
        fileSize: 524288
      },
      {
        id: 'demo-3',
        dataType: 'archive',
        fileName: 'kpi-data-2025.zip',
        uploadDate: '2025-06-19T09:15:00Z', 
        status: 'Processing',
        recordCount: 0,
        fileSize: 10485760
      }
    ];
  }

  // üì§ Import d·ªØ li·ªáu theo lo·∫°i v·ªõi progress tracking v√† audio notification
  async importData(dataType, files, options = {}) {
    try {
      const formData = new FormData();
      
      // Th√™m files v√†o FormData
      files.forEach(file => {
        formData.append('Files', file);
      });

      // Th√™m c√°c t√πy ch·ªçn
      if (options.archivePassword) {
        formData.append('ArchivePassword', options.archivePassword);
      }
      
      if (options.notes) {
        formData.append('Notes', options.notes);
      }

      // T√≠nh t·ªïng file size ƒë·ªÉ track progress
      const totalSize = files.reduce((sum, file) => sum + file.size, 0);
      const startTime = Date.now();
      let lastLoadedAmount = 0;
      let lastTime = startTime;

      // Store this context for callback
      const self = this;

      const response = await api.post(`${this.baseURL}/import/${dataType}`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        timeout: 600000, // 10 ph√∫t timeout cho upload file l·ªõn
        maxContentLength: 500 * 1024 * 1024, // 500MB max
        maxBodyLength: 500 * 1024 * 1024,
        onUploadProgress: (progressEvent) => {
          const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          const currentTime = Date.now();
          const elapsed = currentTime - startTime;
          
          // T√≠nh t·ªëc ƒë·ªô upload hi·ªán t·∫°i (smoothing v·ªõi exponential moving average)
          const timeDelta = currentTime - lastTime;
          const loadedDelta = progressEvent.loaded - lastLoadedAmount;
          
          if (timeDelta > 0) {
            const currentSpeed = loadedDelta / timeDelta * 1000; // bytes per second
            const remainingBytes = progressEvent.total - progressEvent.loaded;
            
            // ∆Ø·ªõc t√≠nh th·ªùi gian c√≤n l·∫°i d·ª±a tr√™n t·ªëc ƒë·ªô hi·ªán t·∫°i
            let remainingTime = remainingBytes > 0 && currentSpeed > 0 ? (remainingBytes / currentSpeed * 1000) : 0;
            
            // N·∫øu g·∫ßn xong (> 95%) th√¨ ∆∞·ªõc t√≠nh th·ªùi gian c√≤n l·∫°i ng·∫Øn h∆°n
            if (percentCompleted > 95) {
              remainingTime = Math.min(remainingTime, 5000); // t·ªëi ƒëa 5 gi√¢y
            }
            
            console.log(`üìä Ti·∫øn ƒë·ªô upload ${dataType}: ${percentCompleted}%`);
            
            // G·ªçi callback progress n·∫øu c√≥
            if (options.onProgress) {
              console.log(`üìä Progress update: ${percentCompleted}%, Speed: ${self.formatFileSize(currentSpeed)}/s, Remaining: ${self.formatTime(remainingTime)}`);
              options.onProgress({
                loaded: progressEvent.loaded,
                total: progressEvent.total,
                percentage: percentCompleted,
                remainingTime: Math.max(0, remainingTime), // milliseconds
                remainingTimeFormatted: self.formatTime(remainingTime), // mm:ss format
                uploadSpeed: currentSpeed, // bytes per second
                formattedSpeed: self.formatFileSize(currentSpeed) + '/s',
                formattedRemaining: self.formatTime(remainingTime),
                formattedLoaded: self.formatFileSize(progressEvent.loaded),
                formattedTotal: self.formatFileSize(progressEvent.total),
                isNearCompletion: percentCompleted > 95
              });
            }
            
            lastLoadedAmount = progressEvent.loaded;
            lastTime = currentTime;
          }
        }
      });

      // üîä Ph√°t √¢m thanh th√¥ng b√°o ho√†n th√†nh v·ªõi notification
      this.playCompletionSound();
      
      // Hi·ªÉn th·ªã browser notification n·∫øu ƒë∆∞·ª£c ph√©p
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('üéâ ƒê√£ upload xong!', {
          body: `Import d·ªØ li·ªáu ${dataType} ƒë√£ ho√†n t·∫•t th√†nh c√¥ng`,
          icon: '/favicon.ico',
          tag: 'upload-complete'
        });
      }

      // üîß Parse .NET $values format trong response
      let data = response.data;
      if (data && data.$values) {
        data = data.$values;
      }

      return {
        success: true,
        data: data
      };
    } catch (error) {
      console.error(`‚ùå L·ªói import d·ªØ li·ªáu ${dataType}:`, error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üëÅÔ∏è Xem tr∆∞·ªõc d·ªØ li·ªáu ƒë√£ import
  async previewData(importId) {
    try {
      const response = await api.get(`${this.baseURL}/${importId}/preview`);
      
      // üîß Parse .NET $values format
      let data = response.data;
      if (data && data.$values) {
        data = data.$values;
      }
      
      return {
        success: true,
        data: data
      };
    } catch (error) {
      console.error('‚ùå L·ªói xem tr∆∞·ªõc d·ªØ li·ªáu:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üóëÔ∏è X√≥a d·ªØ li·ªáu import
  async deleteImport(importId) {
    try {
      const response = await api.delete(`${this.baseURL}/${importId}`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói x√≥a d·ªØ li·ªáu import:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üìÖ L·∫•y d·ªØ li·ªáu import theo ng√†y sao k√™
  async getImportsByStatementDate(statementDate, fileType = null) {
    try {
      const params = new URLSearchParams();
      if (statementDate) {
        params.append('statementDate', statementDate);
      }
      if (fileType) {
        params.append('fileType', fileType);
      }
      
      const response = await api.get(`/DataImport/by-statement-date?${params.toString()}`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói l·∫•y d·ªØ li·ªáu theo ng√†y sao k√™:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üì¶ L·∫•y d·ªØ li·ªáu ƒë√£ n√©n
  async getDecompressedData(importId) {
    try {
      const response = await api.get(`/DataImport/${importId}/decompress`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói gi·∫£i n√©n d·ªØ li·ªáu:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üì§ Import d·ªØ li·ªáu m·ªõi v·ªõi t√≠nh nƒÉng statement date v√† compression
  async importDataNew(files, category = 'General') {
    try {
      const formData = new FormData();
      
      // Th√™m files v√†o FormData
      files.forEach(file => {
        formData.append('Files', file);
      });

      // Th√™m category
      formData.append('Category', category);

      const response = await api.post('/DataImport/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        timeout: 300000 // 5 ph√∫t timeout cho upload file l·ªõn
      });

      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói import d·ªØ li·ªáu:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üìã L·∫•y t·∫•t c·∫£ d·ªØ li·ªáu import t·ª´ API m·ªõi
  async getAllImportsNew() {
    try {
      const response = await api.get('/DataImport');
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói l·∫•y danh s√°ch import:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üóëÔ∏è X√≥a to√†n b·ªô d·ªØ li·ªáu import
  async clearAllData() {
    try {
      const response = await api.delete(`${this.baseURL}/clear-all`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói x√≥a to√†n b·ªô d·ªØ li·ªáu:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üîç Ki·ªÉm tra d·ªØ li·ªáu tr√πng l·∫∑p theo ng√†y sao k√™
  async checkDuplicateData(dataType, statementDate, fileName = null) {
    try {
      let url = `${this.baseURL}/check-duplicate/${dataType}/${statementDate}`;
      if (fileName) {
        url += `?fileName=${encodeURIComponent(fileName)}`;
      }
      const response = await api.get(url);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói ki·ªÉm tra d·ªØ li·ªáu tr√πng l·∫∑p:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üóëÔ∏è X√≥a d·ªØ li·ªáu theo ng√†y sao k√™
  async deleteByStatementDate(dataType, statementDate) {
    try {
      const response = await api.delete(`${this.baseURL}/by-date/${dataType}/${statementDate}`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói x√≥a d·ªØ li·ªáu theo ng√†y:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üìã L·∫•y d·ªØ li·ªáu theo ng√†y sao k√™
  async getByStatementDate(dataType, statementDate) {
    try {
      const response = await api.get(`${this.baseURL}/by-date/${dataType}/${statementDate}`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói l·∫•y d·ªØ li·ªáu theo ng√†y:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üìã L·∫•y d·ªØ li·ªáu theo kho·∫£ng ng√†y
  async getByDateRange(dataType, fromDate, toDate) {
    try {
      const response = await api.get(`${this.baseURL}/by-date-range/${dataType}?fromDate=${fromDate}&toDate=${toDate}`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói l·∫•y d·ªØ li·ªáu theo kho·∫£ng ng√†y:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üóÑÔ∏è L·∫•y d·ªØ li·ªáu th√¥ tr·ª±c ti·∫øp t·ª´ b·∫£ng ƒë·ªông
  async getRawDataFromTable(dataType, statementDate = null) {
    try {
      const params = new URLSearchParams();
      if (statementDate) {
        params.append('statementDate', statementDate);
      }
      
      const url = `${this.baseURL}/table/${dataType}${params.toString() ? '?' + params.toString() : ''}`;
      const response = await api.get(url);
      
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error(`‚ùå L·ªói l·∫•y d·ªØ li·ªáu th√¥ t·ª´ b·∫£ng ${dataType}:`, error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server',
        details: error.response?.data?.details || null
      };
    }
  }

  // üîß Utility methods

  // üìã ƒê·ªãnh nghƒ©a c√°c lo·∫°i d·ªØ li·ªáu v√† m√¥ t·∫£
  getDataTypeDefinitions() {
    return {
      'LN01': {
        name: 'LN01',
        description: 'D·ªØ li·ªáu LOAN',
        icon: 'üí∞',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'LN01'
      },
      'LN02': {
        name: 'LN02',
        description: 'Sao k√™ bi·∫øn ƒë·ªông nh√≥m n·ª£',
        icon: 'üîÑ',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'LN02'
      },
      'LN03': {
        name: 'LN03', 
        description: 'D·ªØ li·ªáu N·ª£ XLRR',
        icon: 'üìä',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'LN03'
      },
      'DP01': {
        name: 'DP01',
        description: 'D·ªØ li·ªáu Ti·ªÅn g·ª≠i',
        icon: 'üè¶',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'DP01'
      },
      'EI01': {
        name: 'EI01',
        description: 'D·ªØ li·ªáu mobile banking',
        icon: 'üì±',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'EI01'
      },
      'GL01': {
        name: 'GL01',
        description: 'D·ªØ li·ªáu b√∫t to√°n GDV',
        icon: '‚úçÔ∏è',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'GL01'
      },
      'DPDA': {
        name: 'DPDA',
        description: 'D·ªØ li·ªáu sao k√™ ph√°t h√†nh th·∫ª',
        icon: 'üí≥',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'DPDA'
      },
      'DB01': {
        name: 'DB01',
        description: 'Sao k√™ TSDB v√† Kh√¥ng TSDB',
        icon: 'üìã',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'DB01'
      },
      'KH03': {
        name: 'KH03',
        description: 'Sao k√™ Kh√°ch h√†ng ph√°p nh√¢n',
        icon: 'üè¢',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'KH03'
      },
      'BC57': {
        name: 'BC57',
        description: 'Sao k√™ L√£i d·ª± thu',
        icon: 'üìà',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'BC57'
      },
      'RR01': {
        name: 'RR01',
        description: 'Sao k√™ d∆∞ n·ª£ g·ªëc, l√£i XLRR',
        icon: 'üìâ',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'RR01'
      },
      '7800_DT_KHKD1': {
        name: '7800_DT_KHKD1',
        description: 'B√°o c√°o KHKD (DT)',
        icon: 'üìë',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: '7800_DT_KHKD1'
      },
      'GLCB41': {
        name: 'GLCB41',
        description: 'B·∫£ng c√¢n ƒë·ªëi',
        icon: '‚öñÔ∏è',
        acceptedFormats: ['.csv', '.xlsx', '.xls', '.zip', '.rar', '.7z'],
        requiredKeyword: 'GLCB41'
      }
    };
  }

  // üîç Validate file for import
  validateFile(file, dataType) {
    if (!file) {
      return { valid: false, error: 'File kh√¥ng h·ª£p l·ªá' }
    }
    
    if (!dataType) {
      return { valid: false, error: 'Ch∆∞a ch·ªçn lo·∫°i d·ªØ li·ªáu' }
    }
    
    const dataTypeDef = this.getDataTypeDefinitions()[dataType]
    if (!dataTypeDef) {
      return { valid: false, error: 'Lo·∫°i d·ªØ li·ªáu kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£' }
    }
    
    const fileName = file.name.toLowerCase()
    const validExtensions = [...dataTypeDef.acceptedFormats, '.zip', '.7z', '.rar']
    const hasValidExtension = validExtensions.some(ext => fileName.endsWith(ext.toLowerCase()))
    
    if (!hasValidExtension) {
      return { 
        valid: false, 
        error: `File ph·∫£i c√≥ ƒë·ªãnh d·∫°ng: ${validExtensions.join(', ')}` 
      }
    }
    
    // Check if filename contains data type (for non-archive files)
    if (!this.isArchiveFile(fileName) && !fileName.includes(dataType.toLowerCase())) {
      return { 
        valid: false, 
        error: `T√™n file ph·∫£i ch·ª©a m√£ lo·∫°i d·ªØ li·ªáu '${dataType}'` 
      }
    }
    
    return { valid: true }
  }

  // üóÇÔ∏è Ki·ªÉm tra file n√©n
  isArchiveFile(fileName) {
    const archiveExtensions = ['.zip', '.7z', '.rar', '.tar', '.gz'];
    const extension = '.' + fileName.split('.').pop().toLowerCase();
    return archiveExtensions.includes(extension);
  }

  // üìÖ Tr√≠ch xu·∫•t ng√†y t·ª´ t√™n file (yyyymmdd)
  extractDateFromFileName(fileName) {
    const dateMatch = fileName.match(/(\d{8})/);
    if (dateMatch) {
      const dateStr = dateMatch[1];
      const year = dateStr.substring(0, 4);
      const month = dateStr.substring(4, 6);
      const day = dateStr.substring(6, 8);
      
      try {
        const date = new Date(year, month - 1, day);
        if (!isNaN(date.getTime())) {
          return date;
        }
      } catch (e) {
        // Ignore date parsing errors
      }
    }
    return null;
  }

  // üé® L·∫•y m√†u s·∫Øc cho lo·∫°i d·ªØ li·ªáu - ƒê·ªíNG B·ªò T·∫§T C·∫¢ 13 LO·∫†I
  getDataTypeColor(dataType) {
    const colors = {
      'LN01': '#10B981', // green - D·ªØ li·ªáu LOAN
      'LN02': '#059669', // emerald - Sao k√™ bi·∫øn ƒë·ªông nh√≥m n·ª£
      'LN03': '#F59E0B', // amber - D·ªØ li·ªáu N·ª£ XLRR
      'DP01': '#3B82F6', // blue - D·ªØ li·ªáu Ti·ªÅn g·ª≠i
      'EI01': '#8B5CF6', // purple - D·ªØ li·ªáu mobile banking
      'GL01': '#EF4444', // red - D·ªØ li·ªáu b√∫t to√°n GDV
      'DPDA': '#06B6D4', // cyan - D·ªØ li·ªáu sao k√™ ph√°t h√†nh th·∫ª
      'DB01': '#84CC16', // lime - Sao k√™ TSDB v√† Kh√¥ng TSDB
      'KH03': '#F97316', // orange - Sao k√™ Kh√°ch h√†ng ph√°p nh√¢n
      'BC57': '#EC4899', // pink - Sao k√™ L√£i d·ª± thu
      'RR01': '#DC2626', // red-600 - Sao k√™ d∆∞ n·ª£ g·ªëc, l√£i XLRR
      '7800_DT_KHKD1': '#7C2D12', // brown - B√°o c√°o KHKD (DT)
      'GLCB41': '#1E40AF' // blue-800 - B·∫£ng c√¢n ƒë·ªëi
    };
    return colors[dataType] || '#6B7280'; // gray default
  }

  // üìä Format s·ªë l∆∞·ª£ng records
  formatRecordCount(count) {
    if (count >= 1000000) {
      return `${(count / 1000000).toFixed(1)}M`;
    } else if (count >= 1000) {
      return `${(count / 1000).toFixed(1)}K`;
    }
    return count.toString();
  }

  // üìÖ Format ng√†y
  formatDate(date) {
    if (!date) return 'N/A';
    
    if (typeof date === 'string') {
      date = new Date(date);
    }
    
    return date.toLocaleDateString('vi-VN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  // üîä Ph√°t √¢m thanh th√¥ng b√°o ho√†n th√†nh
  playCompletionSound() {
    try {
      // T·∫°o AudioContext ƒë·ªÉ ph√°t √¢m thanh
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // T·∫°o √¢m thanh th√¥ng b√°o d·∫°ng melody (3 n·ªët nh·∫°c)
      const notes = [
        { freq: 523.25, duration: 0.2 }, // C5
        { freq: 659.25, duration: 0.2 }, // E5  
        { freq: 783.99, duration: 0.4 }  // G5
      ];
      
      let startTime = audioContext.currentTime;
      
      notes.forEach((note, index) => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        // K·∫øt n·ªëi audio nodes
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Thi·∫øt l·∫≠p t·∫ßn s·ªë v√† √¢m l∆∞·ª£ng
        oscillator.frequency.setValueAtTime(note.freq, startTime);
        oscillator.type = 'sine'; // √Çm thanh m·ªÅm m·∫°i
        
        // Envelope cho √¢m thanh m∆∞·ª£t m√†
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
        
        // Ph√°t √¢m thanh
        oscillator.start(startTime);
        oscillator.stop(startTime + note.duration);
        
        startTime += note.duration + 0.1; // Gap gi·ªØa c√°c n·ªët
      });
      
      console.log('üîä ƒê√£ ph√°t √¢m thanh th√¥ng b√°o "ƒê√£ upload xong"');
    } catch (error) {
      console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ ph√°t √¢m thanh:', error);
      // Fallback: s·ª≠ d·ª•ng notification API n·∫øu c√≥
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('üéâ ƒê√£ upload xong!', {
          body: 'Import d·ªØ li·ªáu ƒë√£ ho√†n t·∫•t',
          icon: '/favicon.ico',
          tag: 'upload-complete'
        });
      }
    }
  }

  // ‚è∞ Format th·ªùi gian t·ª´ milliseconds sang mm:ss
  formatTime(milliseconds) {
    if (!milliseconds || milliseconds <= 0) return '00:00';
    
    const totalSeconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }

  // üìÅ Format file size to human readable format
  formatFileSize(bytes) {
    if (!bytes || bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  // üìÅ Format file size (bytes to human readable) - Legacy method
  formatBytes(bytes) {
    return this.formatFileSize(bytes);
  }

  // üìä L·∫•y th·ªëng k√™ t·ªïng quan
  getImportStats(imports) {
    const stats = {
      totalImports: imports.length,
      totalRecords: 0,
      dataTypes: {},
      recentImports: [],
      successfulImports: 0,
      failedImports: 0
    };

    imports.forEach(imp => {
      stats.totalRecords += imp.recordsCount || 0;
      
      // ƒê·∫øm theo lo·∫°i d·ªØ li·ªáu
      if (!stats.dataTypes[imp.dataType]) {
        stats.dataTypes[imp.dataType] = {
          count: 0,
          records: 0
        };
      }
      stats.dataTypes[imp.dataType].count++;
      stats.dataTypes[imp.dataType].records += imp.recordsCount || 0;

      // ƒê·∫øm th√†nh c√¥ng/th·∫•t b·∫°i
      if (imp.status === 'Completed') {
        stats.successfulImports++;
      } else if (imp.status === 'Failed') {
        stats.failedImports++;
      }
    });

    // L·∫•y 5 import g·∫ßn nh·∫•t
    stats.recentImports = imports
      .sort((a, b) => new Date(b.importDate) - new Date(a.importDate))
      .slice(0, 5);

    return stats;
  }

  // ‚ö° Temporal Table APIs (Migrated from SCD Type 2)
  
  // üìã L·∫•y danh s√°ch imports v·ªõi temporal data
  async getOptimizedImports(page = 1, pageSize = 50, searchTerm = '', sortBy = 'ImportDate', sortOrder = 'desc') {
    try {
      const params = new URLSearchParams({
        page: page.toString(),
        pageSize: pageSize.toString(),
        searchTerm: searchTerm || '',
        sortBy: sortBy || 'ImportDate',
        sortOrder: sortOrder || 'desc'
      });

      const response = await api.get(`${this.baseURL}/temporal/query/RawDataImport?${params.toString()}`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói l·∫•y danh s√°ch imports t·ª´ temporal table:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üìä L·∫•y records v·ªõi temporal queries
  async getOptimizedRecords(importId, offset = 0, limit = 100, searchTerm = '') {
    try {
      const params = new URLSearchParams({
        page: Math.floor(offset / limit) + 1,
        pageSize: limit.toString(),
        searchTerm: searchTerm || '',
        importId: importId.toString()
      });

      const response = await api.get(`${this.baseURL}/temporal/query/RawData?${params.toString()}`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói l·∫•y records t·ª´ temporal table:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üîÑ Th√™m c√°c ph∆∞∆°ng th·ª©c m·ªõi cho Temporal Tables (Migrated from SCD Type 2)

  // üìà L·∫•y dashboard statistics t·ª´ temporal data
  async getDashboardStats() {
    try {
      const response = await api.get(`${this.baseURL}/temporal/stats/RawData`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói l·∫•y dashboard stats t·ª´ temporal table:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üéØ T√¨m ki·∫øm n√¢ng cao v·ªõi temporal data
  async advancedSearch(searchTerm, dataTypes = [], dateFrom = null, dateTo = null, page = 1, pageSize = 50) {
    try {
      const params = new URLSearchParams({
        searchTerm: searchTerm || '',
        page: page.toString(),
        pageSize: pageSize.toString()
      });

      if (dataTypes.length > 0) {
        dataTypes.forEach(type => params.append('dataTypes', type));
      }
      if (dateFrom) params.append('startDate', dateFrom);
      if (dateTo) params.append('endDate', dateTo);

      const response = await api.get(`${this.baseURL}/temporal/query/RawData?${params.toString()}`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói t√¨m ki·∫øm n√¢ng cao trong temporal table:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üìä L·∫•y th·ªëng k√™ hi·ªáu su·∫•t t·ª´ temporal table
  async getPerformanceStats(timeRange = '24h') {
    try {
      const response = await api.get(`${this.baseURL}/temporal/stats/RawData?timeRange=${timeRange}`);
      return {
        success: true,
        data: response.data
      };
    } catch (error) {
      console.error('‚ùå L·ªói l·∫•y th·ªëng k√™ hi·ªáu su·∫•t t·ª´ temporal table:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üîÑ Refresh temporal table statistics and indexes
  async refreshCache(cacheKey) {
    try {
      // For temporal tables, we refresh statistics instead of cache
      const response = await api.post(`${this.baseURL}/temporal/index/RawData`);
      return {
        success: true,
        data: {
          message: 'Temporal table statistics and indexes refreshed successfully',
          timestamp: new Date().toISOString(),
          cacheKey: cacheKey
        }
      };
    } catch (error) {
      console.error('‚ùå L·ªói refresh temporal table statistics:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'L·ªói k·∫øt n·ªëi server'
      };
    }
  }

  // üé® Performance utility methods
  
  // üìä Format performance metrics
  formatPerformanceMetric(value, unit = 'ms') {
    if (value < 1000 && unit === 'ms') {
      return `${Math.round(value)}ms`;
    } else if (value >= 1000 && unit === 'ms') {
      return `${(value / 1000).toFixed(2)}s`;
    }
    return `${value}${unit}`;
  }

  // üéØ Calculate cache hit rate percentage
  calculateCacheHitRate(hits, misses) {
    const total = hits + misses;
    if (total === 0) return 0;
    return Math.round((hits / total) * 100);
  }

  // üìà Get performance color based on response time
  getPerformanceColor(responseTime) {
    if (responseTime < 100) return '#52c41a'; // green - excellent
    if (responseTime < 500) return '#faad14'; // yellow - good
    if (responseTime < 1000) return '#fa8c16'; // orange - fair
    return '#f5222d'; // red - poor
  }

  // üîç Format search highlight
  formatSearchHighlight(text, searchTerm) {
    if (!searchTerm || !text) return text;
    
    const regex = new RegExp(`(${searchTerm})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }
}

export default new RawDataService();
